
 <!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="github-markdown.css">
  <style>
      .markdown-body {
          box-sizing: border-box;
          min-width: 200px;
          max-width: 980px;
          margin: 0 auto;
          padding: 45px;
      }
  </style>

 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" >
</head>

  <body>
    <article class="markdown-body">

 <div id="wikiheader">

 <span style="font-size:120%;font-weight:bold">RegularExpressionReference</span>
 &nbsp;
 <div>

 <i>Reference for foma regular expression syntax.</i>


 </div>
 </div>

 <div id="wikicontent">
 <div class="vt" id="wikimaincol">
 <h1><a name="Regular_expression_operators"></a>Regular expression operators<a href="#Regular_expression_operators" class="section_anchor"></a></h1><h2><a name="Concatenation_(X_Y)"></a>Concatenation (X Y)<a href="#Concatenation_(X_Y)" class="section_anchor"></a></h2><p>The language or relation X concatenated with Y. The operator is not overtly signaled by spacing, etc., and two adjacent regular expressions will be concatenated regardless of white space when found at the level of precedence of the concatenation operator by the regular expression parser. </p><p>Restrictions: none </p><h2><a name="Kleene_star_(X_)"></a>Kleene star (X<strong>&#42;)<a href="#Kleene_star_(X_)" class="section_anchor"></a></h2><p>Zero or more iterations of <tt>X</tt>. </strong></p><p>Restrictions: none </p><h2><a name="Kleene_plus_(X+)"></a>Kleene plus (X+)<a href="#Kleene_plus_(X+)" class="section_anchor"></a></h2><p>One or more iterations of <tt>X</tt>. Equivalent to <tt>[X X*]</tt>. </p><p>Restrictions: none </p><h2><a name="Iteration_operators"></a>Iteration operators<a href="#Iteration_operators" class="section_anchor"></a></h2><p>In addition to the Kleene closures, there are a number of m-n-ary iteration operators: </p><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> Iteration operators                          </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>X^n</tt>      </td><td style="border: 1px solid #ccc; padding: 5px;"> exactly n iterations of X       </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>X^&gt;n</tt>     </td><td style="border: 1px solid #ccc; padding: 5px;"> at least n iterations of X      </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>X^&lt;n</tt>     </td><td style="border: 1px solid #ccc; padding: 5px;"> less than n iterations of X     </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>X^{m,n}</tt>  </td><td style="border: 1px solid #ccc; padding: 5px;"> between m and n iterations of X </td></tr> </table></p><p>Restrictions: none </p><h2><a name="Union_(X_|_Y)"></a>Union (X | Y)<a href="#Union_(X_|_Y)" class="section_anchor"></a></h2><p>Returns the union (disjunction) of FSMs <tt>X</tt> and <tt>Y</tt>. </p><p>Notational variants: <tt>X</tt> ∪ <tt>Y</tt> (UNION, U+222A), <tt>X</tt> ∨ <tt>Y</tt> (LOGICAL OR, U+2228) </p><p>Restrictions: none </p><h2><a name="Intersection_(X_&amp;_Y)"></a>Intersection (X &amp; Y)<a href="#Intersection_(X_&amp;_Y)" class="section_anchor"></a></h2><p>Returns the intersection (conjunction) of FSMs <tt>X</tt> and <tt>Y</tt>. </p><p>Notational variants: <tt>X</tt> ∩ <tt>Y</tt> (UNION, U+2229), <tt>X</tt> ∧ <tt>Y</tt> (LOGICAL AND, U+2227) </p><p>Restrictions: foma always calculates the path intersection of two FSMs. This may not be the logical intersection of the relations <tt>X</tt> and <tt>Y</tt> if <tt>X</tt> and <tt>Y</tt> are transducers and not automata. </p><h2><a name="Subtraction_(X_-_Y)"></a>Subtraction (X - Y)<a href="#Subtraction_(X_-_Y)" class="section_anchor"></a></h2><p>Returns the difference of FSMs <tt>X</tt> and <tt>Y</tt>. </p><p>Restrictions: foma always calculates the path subtraction of two FSMs. This may not be the logical difference of the relations <tt>X</tt> and <tt>Y</tt> if <tt>X</tt> and <tt>Y</tt> are transducers and not automata. </p><h2><a name="Complement_(~X)"></a>Complement (~X)<a href="#Complement_(~X)" class="section_anchor"></a></h2><p>Calculates the complement set of <tt>X</tt>. </p><p>Notational variants: ¬<tt>X</tt> (NOT SIGN, U+00AC) </p><p>Restrictions: undefined for non-identity transducers. </p><h2><a name="Composition_(X_.o._Y)"></a>Composition (X .o. Y)<a href="#Composition_(X_.o._Y)" class="section_anchor"></a></h2><p>Calculates the composite transducer of relations <tt>X</tt> and <tt>Y</tt>. </p><p>Notational variants: <tt>X</tt> ∘ <tt>Y</tt> (RING OPERATOR, U+2218) </p><p>Restrictions: none </p><h2><a name="Substitution_(`[X,Y,Z])"></a>Substitution (`[X,Y,Z])<a href="#Substitution_(`[X,Y,Z])" class="section_anchor"></a></h2><p>Substitutes all occurrences of symbol <tt>Y</tt> in FSM <tt>X</tt> by <tt>Z</tt>. </p><p>Restrictions: none </p><h2><a name="Optionality_(X)"></a>Optionality (X)<a href="#Optionality_(X)" class="section_anchor"></a></h2><p>Defines the language or relation that contains zero or one iteration of <tt>X</tt>. Equivalent to <tt>[X | 0]</tt>. </p><p>Restrictions: none </p><h2><a name="Domain_extraction_(X.u)"></a>Domain extraction (X.u)<a href="#Domain_extraction_(X.u)" class="section_anchor"></a></h2><p>Extracts the domain from a FSM.   </p><p>Notational variants: X₁ (SUBSCRIPT ONE, U+2081) </p><p>Restrictions: none </p><h2><a name="Range_exctraction_(X.l)"></a>Range exctraction (X.l)<a href="#Range_exctraction_(X.l)" class="section_anchor"></a></h2><p>Extracts the range from a FSM.   </p><p>Notational variants: <tt>X</tt>₂ (SUBSCRIPT TWO, U+2082) </p><p>Restrictions: none </p><h2><a name="Inversion_(X.i)"></a>Inversion (X.i)<a href="#Inversion_(X.i)" class="section_anchor"></a></h2><p>Inverts a FSM. </p><p>Notational variants: <tt>X</tt>⁻¹ (SUPERSCRIPT MINUS SUPERSCRIPT ONE, U+207B U+00B9) </p><p>Restrictions: none </p><h2><a name="Term_negation_(\X)"></a>Term negation (\X)<a href="#Term_negation_(\X)" class="section_anchor"></a></h2><p>Any single symbol except <tt>X</tt>.  Equivalent to <tt>[? - X]</tt>.  </p><p>Restrictions: see subtraction </p><h2><a name="Cross_product_(X:Y)"></a>Cross product (X:Y)<a href="#Cross_product_(X:Y)" class="section_anchor"></a></h2><p>Calculates the cross product (or Cartesian product) of FSMs <tt>X</tt> and <tt>Y</tt> producing a transducer representing the relation where every string in <tt>X</tt> is paired with every string in <tt>Y</tt>. </p><p>Notational variants: X .x. Y, X × Y (MULTIPLICATION SIGN, U+00D7), both with lower precedence than <tt>:</tt> </p><p>Restrictions: undefined if <tt>X</tt> and <tt>Y</tt> are not both automata. </p><h2><a name="Ignore_(X/Y)"></a>Ignore (X/Y)<a href="#Ignore_(X/Y)" class="section_anchor"></a></h2><p>Denotes the language where instances of Y are arbitrarily interspersed in the language X. </p><p>Restrictions: not well defined for transducers.  </p><h2><a name="Ignore_inside_(X./.Y)"></a>Ignore inside (X./.Y)<a href="#Ignore_inside_(X./.Y)" class="section_anchor"></a></h2><p>Denotes the language where instances of Y are arbitrarily interspersed in the language X, except that the first symbol and last symbol belong to X. </p><p>Restrictions: not well-defined for transducers. </p><h2><a name="Left_quotient_(X\\\Y)"></a>Left quotient (X\\\Y)<a href="#Left_quotient_(X\\\Y)" class="section_anchor"></a></h2><p>The operation <tt>X\\\Y</tt> is defined as: {w <tt>|</tt> ∃x((x ∈ X) ∧ (xw ∈ Y )}.  Informally: the set of suffixes one can add to strings in X to get strings from Y. </p><p>Restrictions: not well-defined for transducers. </p><h2><a name="Right_quotient_(X///Y)"></a>Right quotient (X///Y)<a href="#Right_quotient_(X///Y)" class="section_anchor"></a></h2><p>The operation <tt>X</tt><tt>///</tt><tt>Y</tt> is defined as: {w <tt>|</tt> ∃x((x ∈ Y ) ∧ (wx ∈ X)}. Informally, this is the set of prefixes one can add to Y to get strings from X. </p><p>Restrictions: not well-defined for transducers. </p><h2><a name="Precedes_(X&lt;Y)"></a>Precedes (X&lt;Y)<a href="#Precedes_(X&lt;Y)" class="section_anchor"></a></h2><p>Denotes the languages where every string from <tt>X</tt> precedes every string from <tt>Y</tt>.  The precedence need not be immediate. </p><p>Restrictions: not well-defined for transducers. </p><h2><a name="Follows_(X&gt;Y)"></a>Follows (X&gt;Y)<a href="#Follows_(X&gt;Y)" class="section_anchor"></a></h2><p>Denotes the languages where every string from <tt>X</tt> follows every string from <tt>Y</tt>.  The precedence need not be immediate. </p><p>Restrictions: not well-defined for transducers. </p><h2><a name="Shuffle_(X_&lt;&gt;_Y)"></a>Shuffle (X &lt;&gt; Y)<a href="#Shuffle_(X_&lt;&gt;_Y)" class="section_anchor"></a></h2><p>The shuffle (or asynchronous) product of <tt>X</tt> and <tt>Y</tt>, i.e. the set of words formed by any method of ‘shuffling’ the contents of <tt>X</tt> with <tt>Y</tt>.  The shuffle is not perfect. </p><p>Notational variants: <tt>X</tt> ∥ <tt>Y</tt> (PARALLEL TO, U+2225) </p><p>Restrictions: none </p><h2><a name="Containment_operators_($X,_$.X,_$?X)"></a>Containment operators ($X, $.X, $?X)<a href="#Containment_operators_($X,_$.X,_$?X)" class="section_anchor"></a></h2><p>The operator $X denotes the language that contains a substring drawn from the language X. This is equivalent to <tt>[?* X ?*]</tt>.  The operator <tt>$.X</tt> denotes the language that contains exactly one substring drawn from the language <tt>X</tt>, while <tt>$?X</tt> denotes the language that contains at most one substring from X. </p><p>Restrictions: <tt>$.X</tt> and <tt>$?X</tt> are not well-defined for transducers. </p><h2><a name="Context_restriction_(X_=&gt;_Y1_Z1,_...,_Yn_Zn)"></a>Context restriction (X =&gt; Y1 <i> Z1, ..., Yn </i> Zn)<a href="#Context_restriction_(X_=&gt;_Y1_Z1,_...,_Yn_Zn)" class="section_anchor"></a></h2><p>Denotes the language where every instance of a string from <tt>X</tt> is surrounded by string from some pair Yi and Zi on the left and right, respectively. </p><p>Restrictions: not well-defined for transducers. </p><h2><a name="Priority_unions_(X_.P._Y,_X_.p._Y)"></a>Priority unions (X .P. Y, X .p. Y)<a href="#Priority_unions_(X_.P._Y,_X_.p._Y)" class="section_anchor"></a></h2><p>Th upper-side priority union <tt>X .P. Y</tt> denotes the union of relations <tt>X</tt> and <tt>Y</tt>, with relations in Y discarded if a relation in X have the same input (domain).  Equivalent to <tt>[X | [ ̃[X.u] .o. Y]]</tt>.  The lower-side priority union is similar, except a relation in X has precedence over a relation in Y based on the range, not the domain. </p><p>Restrictions: none </p><hr/><p><img src="regexref-priorityunion.png" /> </p><hr/><h2><a name="Lenient_composition_(X_.O._Y)"></a>Lenient composition (X .O. Y)<a href="#Lenient_composition_(X_.O._Y)" class="section_anchor"></a></h2><p>The &#x27;lenient&#x27; composition of <tt>X</tt> with <tt>Y</tt>.  For those relations where strings in the domain of Y does not include some possible string from the range of <tt>X</tt>, the relation <tt>X</tt> is not composed with <tt>Y</tt>. Equivalent to <tt>[X .o. Y] .P. Y</tt>.  See Karttunen (1998) for details and usage. </p><h2><a name="Logical_connectives_(X_→_Y,_X_↔_Y)"></a>Logical connectives (X → Y, X ↔ Y)<a href="#Logical_connectives_(X_&rarr;_Y,_X_&harr;_Y)" class="section_anchor"></a></h2><p>The implication operator and the biconditional are shorthands whose definitions are as follows: </p><ul><li><tt>X</tt> → <tt>Y</tt> is equivalent to <tt>~X | Y</tt> </li><li><tt>X</tt> ↔ <tt>Y</tt> is equivalent to <tt>[~X | Y] &amp; [~Y | X]</tt> </li></ul><h2><a name="Flag_elimination_(X.f)"></a>Flag elimination (X.f)<a href="#Flag_elimination_(X.f)" class="section_anchor"></a></h2><p>Eliminates all flag diacritics in <tt>X</tt> and calculates the equivalent FSM without flags.  If no flags are present, no action is taken. </p><p>Restrictions: none </p><h2><a name="Replacement_operators"></a>Replacement operators<a href="#Replacement_operators" class="section_anchor"></a></h2><p>The most general format of a replacement rule is  </p><pre class="prettyprint">A -&gt; B || L _ R ;</pre><p>which dictates the replacement of sequences <tt>A</tt> with <tt>B</tt> when occurring between <tt>L</tt> and <tt>R</tt>. The replacement arrow (<tt>-&gt;</tt>) can be of various types indicating different replacement strategies, optional replacement (-&gt;), longest-leftmost <tt>@-&gt;</tt>, shortest-leftmost <tt>@&gt;</tt>, etc. The directionality constraint <tt>||</tt> can also vary depending on the application. </p><p>All replacement operators allow context specification through one of the directionality markers. </p><p>The directionality constraint DIR can be one of: </p><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> DIR                </td><td style="border: 1px solid #ccc; padding: 5px;"> Interpretation                          </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>|</tt><tt>|</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> left and right contexts hold on input side            </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>\\</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> left holds on input side, right holds on output side  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>//</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> left holds on output side, right holds on input side  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>\/</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> left holds on output side, right holds on output side </td></tr> </table></p><p>The following replacement operators are available: </p><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> Operator  </td><td style="border: 1px solid #ccc; padding: 5px;"> Type   </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>-&gt;</tt>    </td><td style="border: 1px solid #ccc; padding: 5px;"> Unconditional replacement  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> &lt;- </tt>    </td><td style="border: 1px solid #ccc; padding: 5px;"> Unconditional inverse replacement   </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> &lt;-&gt; </tt>   </td><td style="border: 1px solid #ccc; padding: 5px;"> Unconditional replacement and inverse replacement </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> (-&gt;) </tt>  </td><td style="border: 1px solid #ccc; padding: 5px;"> Optional replacement             </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> (&lt;-) </tt>  </td><td style="border: 1px solid #ccc; padding: 5px;"> Optional inverse replacement           </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> (&lt;-&gt;) </tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> Optional replacement and inverse replacement  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> @-&gt; </tt>   </td><td style="border: 1px solid #ccc; padding: 5px;"> Left-to-right longest-match replacement  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> @&gt; </tt>    </td><td style="border: 1px solid #ccc; padding: 5px;"> Left-to-right shortest-match replacement  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> &lt;-@ </tt>   </td><td style="border: 1px solid #ccc; padding: 5px;"> Left-to-right longest-match inverse replacement </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> &lt;@ </tt>    </td><td style="border: 1px solid #ccc; padding: 5px;"> Left-to-right shortest-match inverse replacement  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> (@-&gt;) </tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> Optional left-to-right longest-match replacement  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> (@&gt;) </tt>  </td><td style="border: 1px solid #ccc; padding: 5px;"> Optional left-to-right shortest-match replacement </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> (&lt;-@) </tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> Optional left-to-right longest-match inverse replacement </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt> (&lt;@) </tt>  </td><td style="border: 1px solid #ccc; padding: 5px;"> Optional left-to-right shortest-match replacement  </td></tr> </table></p><h3><a name="Markup_(_..._)"></a>Markup (<tt>...</tt>)<a href="#Markup_(_..._)" class="section_anchor"></a></h3><p>The LHS/RHS of a replacement rule may also be of the format </p><pre class="prettyprint">X -&gt; Y ... Z ;</pre><p>in which case both <tt>Y</tt> and <tt>Z</tt> are inserted around instances of <tt>X</tt>. <tt>Y</tt> or <tt>Z</tt> may be omitted and all contextual specifications are available. </p><h3><a name="Epsilon_modifier_[._.]"></a>Epsilon modifier <tt>[. .]</tt><a href="#Epsilon_modifier_[._.]" class="section_anchor"></a></h3><p>The LHS of a rule may be wrapped in the <i>epsilon modifier</i>, in which case any epsilons on the LHS get a special interpretation, where only one empty string is assumed to exists between each symbol in the input string.  For example, the rule: </p><pre class="prettyprint">[.a*.] -&gt; x </pre><p>will produce a transducer that maps the input string <tt>a</tt> unambiguously to <tt>xxx</tt>. </p><p>Also, <tt>[..]</tt> will simply produce a rule that inserts one instance of the RHS whenever the context is matched: </p><pre class="prettyprint">[..] -&gt; x</pre><p>will map <tt>aaa</tt> to <tt>xaxaxax</tt>. </p><h3><a name="Multiple_contexts"></a>Multiple contexts<a href="#Multiple_contexts" class="section_anchor"></a></h3><p>Several possible contexts can be specified by separating the contexts with a comma.  </p><p>Example: </p><pre class="prettyprint">a -&gt; b || c _ d , e _ f ;</pre><h3><a name="Multiple_left-hand_sides"></a>Multiple left-hand sides<a href="#Multiple_left-hand_sides" class="section_anchor"></a></h3><p>Several left hand sides of a rule can be combined with a comma.  In such a rule, the context specification aplies to all left-hand sides. </p><p>Example: </p><pre class="prettyprint">a -&gt; b , b -&gt; a || c _ d ; </pre><h3><a name="Parallel_rules_(,,)"></a>Parallel rules (,,)<a href="#Parallel_rules_(,,)" class="section_anchor"></a></h3><p>Separate rules can be compiled in parallel by separating each individual rules with a double comma (<tt>,,</tt>), i.e.  </p><pre class="prettyprint">Rule1 ,, Rule2 ,, ... ,, RuleN ;</pre><h3><a name="Transducers_with_backreferences"></a>Transducers with backreferences<a href="#Transducers_with_backreferences" class="section_anchor"></a></h3><p>Rules of the format </p><pre class="prettyprint">T -&gt; || L _ R ;</pre><p>are also possible. Here, T is usually a transducer.  The contexts can be omitted, and several contexts can be specified as with ordinary rules, and the arrow can take any of the standard arrow types. </p><p>The semantics of the rule is that the strings from the input side of <tt>T</tt> are replaced with T. This allows for a more general specification of chunking and insertion rules. </p><p>For example, the rule </p><pre class="prettyprint">0:%[ Chunk 0:%] @-&gt; ;</pre><p>is identical to the chunking rule </p><pre class="prettyprint">Chunk @-&gt; %{ ... %}</pre><p>This type of rule allows for replacements that are otherwise hard to define. Gerdemann and van Noord(1999), who proposed the rule semantics, provide the following example: suppose we have a transducer of word-sequence/abbreviation pairs such as </p><pre class="prettyprint">define Abbr {nondeterministic finite automaton}:{NFA} | {deterministic finite automaton}:{DFA} ;</pre><p>Now, if we wanted to convert all known word sequences into the known acronyms whenever they occur between <tt>&lt;abbr&gt; ... &lt;/abbr&gt;</tt> tags, we can issue the rule: </p><pre class="prettyprint">Abbr -&gt; || {&lt;abbr&gt;} _ {&lt;/abbr&gt;}</pre><p>which would for example transduce <tt>&lt;abbr&gt;nondeterministic finite automaton&lt;/abbr&gt;</tt> to <tt>&lt;abbr&gt;NFA&lt;/abbr&gt;</tt>. </p><h3><a name="Word-boundary_marker_(_.#._)"></a>Word-boundary marker (<tt>.#.</tt>)<a href="#Word-boundary_marker_(_.#._)" class="section_anchor"></a></h3><p>The special word-boundary marker may be used in context specification of both the context restriction operator as well as replacement rules.  </p><p>Example: </p><pre class="prettyprint">a =&gt; _ c | .#. ;</pre><p>specifies the language where <tt>a</tt> must always be followed by <tt>c</tt> or a word boundary.  </p><p>The word-boundary marker has no special meaning in other regular expression constructs; however, any <tt>.#.</tt>-symbols found in a context specification will always be interpreted as a word boundary, and the symbol is removed from the alphabet at the end of replacement rule or context restriction compilation. </p><h1><a name="Built-in_functions"></a>Built-in functions<a href="#Built-in_functions" class="section_anchor"></a></h1><p>All built-in regular expression function names begin with an underscore (<tt>_</tt>). </p><h2><a name="_isunambiguous(X)"></a><tt>_isunambiguous(X)</tt><a href="#_isunambiguous(X)" class="section_anchor"></a></h2><p>Returns the empty string (ε) if <tt>X</tt> is an unambiguous transducer, or the empty language (∅) otherwise. </p><h2><a name="_isidentity(X)"></a><tt>_isidentity(X)</tt><a href="#_isidentity(X)" class="section_anchor"></a></h2><p>Returns the empty string (ε) if <tt>X</tt> is an identity transducer, or the empty language (∅) otherwise. </p><h2><a name="_isfunctional(X)"></a><tt>_isfunctional(X)</tt><a href="#_isfunctional(X)" class="section_anchor"></a></h2><p>Returns the empty string (ε) if <tt>X</tt> is a functional (single-valued) transducer, or the empty language (∅) otherwise. </p><h2><a name="_notid(X)"></a><tt>_notid(X)</tt><a href="#_notid(X)" class="section_anchor"></a></h2><p>Returns an automaton containing all the words in <tt>X</tt> that do not map to themselves (are not in an identity relation). </p><h2><a name="_lm(X)"></a><tt>_lm(X)</tt><a href="#_lm(X)" class="section_anchor"></a></h2><p>Returns the letter machine equivalent to <tt>X</tt>.  A letter machine is a FSM where every transition contains maximally one UTF-8 symbol. </p><h2><a name="_loweruniq(X)"></a><tt>_loweruniq(X)</tt><a href="#_loweruniq(X)" class="section_anchor"></a></h2><p>Modifies <tt>X</tt> in such a way that each input word maps to a unique output word.  Lower-side symbols are replaced by arbitrary symbols from the alphabet.  In case the output side cannot be made unique using only existing symbols in the alphabet, the alphabet is extended with new random symbols to achieve uniqueness. </p><h2><a name="_allfinal(X)"></a><tt>_allfinal(X)</tt><a href="#_allfinal(X)" class="section_anchor"></a></h2><p>Returns the same FSM as <tt>X</tt>, with the exception that all states are marked as final states. </p><h2><a name="_unambpart(X)"></a><tt>_unambpart(X)</tt><a href="#_unambpart(X)" class="section_anchor"></a></h2><p>Returns an FSM containing only those paths in <tt>X</tt> that are unambiguous.  That is, a mapping in <tt>X</tt> is preserved only if its input string has a unique path through the transducer. </p><p>Example: </p><pre class="prettyprint">_unambpart(a:b | a:c | b:c);</pre><p>returns a transducer equivalent to  </p><pre class="prettyprint">b:c</pre><p>since <tt>b:c</tt> is the only unambiguous path with respect to the input side. </p><h2><a name="_ambpart(X)"></a><tt>_ambpart(X)</tt><a href="#_ambpart(X)" class="section_anchor"></a></h2><p>Returns an FSM containing only those paths in <tt>X</tt> that are ambiguous.  That is, a mapping in <tt>X</tt> is preserved only if its input string has at least two paths through the transducer. </p><p>Example: </p><pre class="prettyprint">_ambpart(a:b | a:c | b:c);</pre><p>returns a transducer equivalent to  </p><pre class="prettyprint">a:b | a:c</pre><p>That is, the path containing <tt>b:c</tt> is removes since it is unambiguous.  </p><h2><a name="_ambdom(X)"></a><tt>_ambdom(X)</tt><a href="#_ambdom(X)" class="section_anchor"></a></h2><p>Returns an automaton containing all words in the domain of <tt>X</tt> that yield an ambiguous path through <tt>X</tt>. </p><pre class="prettyprint">_ambdom(a:b | a:c | b:c);</pre><p>returns a an automaton equivalent to  </p><pre class="prettyprint">a</pre><h2><a name="_eq(X,L,R)"></a><tt>_eq(X,L,R)</tt><a href="#_eq(X,L,R)" class="section_anchor"></a></h2><p>Filters from the output side of <tt>X</tt> all those strings where some substrings occurring between the delimiters <tt>L</tt> and <tt>R</tt> are different. </p><p>Example: </p><p>Consider the language <tt>%&lt; a* b %&gt; %&lt; a b* %&gt;</tt>, which contains an infinite number of strings: </p><pre class="prettyprint">&lt;b&gt;&lt;a&gt;
&lt;b&gt;&lt;ab&gt;
&lt;ab&gt;&lt;a&gt;
&lt;ab&gt;&lt;ab&gt;
&lt;ab&gt;&lt;abbb&gt;
...</pre><p>However, only one of the strings in this language has identical substrings between all instances of <tt>&lt;</tt> and <tt>&gt;</tt>, namely <tt>&lt;ab&gt;&lt;ab&gt;</tt>.  Hence, the language containing the single string </p><p><tt>&lt;ab&gt;&lt;ab&gt;</tt> </p><p>is produced by the regular expression: </p><pre class="prettyprint">_eq(%&lt; a* b %&gt; %&lt; a b* %&gt; , %&lt; , %&gt;) ;</pre><p>This operation is mostly used to model reduplication in natural language lexicons.  Usually, the bare words to be reduplicated are marked with delimiters, say <tt>&lt;</tt> and <tt>&gt;</tt>, after which one can produce the reduplicated forms. For example: </p><pre class="prettyprint">define Lexicon {cat}|{dog}|{horse};
define RLexicon %&lt; Lexicon %&gt; (%- %&lt; \[%&lt;|%&gt;]+ %&gt;);
regex _eq(RLexicon, %&lt;, %&gt;) .o. %&lt;|%&gt; -&gt; 0 ;</pre><p>and now we get: </p><pre class="prettyprint">foma[1]: lower-words
cat
cat-cat
dog
dog-dog
horse
horse-horse</pre><h2><a name="_flatten(X,_EPS)"></a><tt>_flatten(X, EPS)</tt><a href="#_flatten(X,_EPS)" class="section_anchor"></a></h2><p>This function converts a transducer into an automaton where input-output symbols are interleaved.  Since epsilons cannot be retained, they need to be converted to the <tt>EPS</tt> symbol. For example: </p><pre class="prettyprint">regex _flatten(a:0 0:b c, &quot;EPS&quot;);</pre><p>produces an automaton which accepts only the word: </p><pre class="prettyprint">a EPS EPS b c c</pre><h2><a name="_addloop(L,_a:b)"></a><tt>_addloop(L, a:b)</tt><a href="#_addloop(L,_a:b)" class="section_anchor"></a></h2><p>This function adds self-loops to all states in <tt>L</tt> with the symbol pair <tt>a:b</tt>. <tt>a</tt> or <tt>b</tt> may be <tt>0</tt>. </p><h2><a name="_addfinalloop(L,_a:b)"></a><tt>_addfinalloop(L, a:b)</tt><a href="#_addfinalloop(L,_a:b)" class="section_anchor"></a></h2><p>Like <tt>_addloop(L, a:b)</tt> but only adds loops at final states. </p><h2><a name="_addnonfinalloop(L,_a:b)"></a><tt>_addnonfinalloop(L, a:b)</tt><a href="#_addnonfinalloop(L,_a:b)" class="section_anchor"></a></h2><p>Like <tt>_addloop(L, a:b)</tt> but only adds loops at nonfinal states. </p><h2><a name="_leftrewr(L,_a:b)"></a><tt>_leftrewr(L, a:b)</tt><a href="#_leftrewr(L,_a:b)" class="section_anchor"></a></h2><p>This is a fast low-level single-symbol rewrite with left contexts only.  It is sometimes useful for constructing complex transducers faster than with the generic operations. </p><pre class="prettyprint">_leftrewr(L, a:b)</pre><p>is semantically equivalent to </p><pre class="prettyprint">a -&gt; b || .#. L _ </pre><p>while  </p><pre class="prettyprint">_leftrewr(?* L, a:b)</pre><p>is equivalent to: </p><pre class="prettyprint">a -&gt; b || L _ </pre><h2><a name="_marktail(L,_a:b)"></a><tt>_marktail(L, a:b)</tt><a href="#_marktail(L,_a:b)" class="section_anchor"></a></h2><p>The function converts L into a single-symbol insertion transducer. As the above, this is a fast state/arc manipulation function that produces a transducer equivalent to a certain operation. In this case: </p><pre class="prettyprint"> _marktail(?* L, 0:x)  </pre><p>is equivalent to </p><pre class="prettyprint">~$x .o. [..] -&gt; x || L _ ; </pre><p>and  </p><pre class="prettyprint">_marktail(?* R.r, 0:x).r</pre><p>is equivalent to </p><pre class="prettyprint">~$x .o. [..] -&gt; x || _ R</pre><h1><a name="First-order_logic_over_substrings_(experimental)"></a>First-order logic over substrings (experimental)<a href="#First-order_logic_over_substrings_(experimental)" class="section_anchor"></a></h1><p><i>SUPPORT FOR FIRST-ORDER LOGIC DISCONTINUED from 0.9.16 onward</i><p>Foma also has a compiler for a type of first-order logic over substrings.  Statements in the first-order logic must begin with a parenthesized quantification of a variable.  When compiling statements in first-order logic, parenthesis symbols <tt>(</tt> and <tt>)</tt> lose their optionality meaning and work as grouping symbols. </p><p>See the article on first-order logic for details. </p><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> Connectives </td><td style="border: 1px solid #ccc; padding: 5px;">              </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>∨</tt>           </td><td style="border: 1px solid #ccc; padding: 5px;"> Disjunction  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>∧</tt>           </td><td style="border: 1px solid #ccc; padding: 5px;"> Conjunction  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>→</tt>           </td><td style="border: 1px solid #ccc; padding: 5px;"> Implication  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>↔</tt>           </td><td style="border: 1px solid #ccc; padding: 5px;"> Biconditional</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>¬</tt>           </td><td style="border: 1px solid #ccc; padding: 5px;"> Negation     </td></tr> </table></p><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> Quantifiers </td><td style="border: 1px solid #ccc; padding: 5px;">  Type       </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> ∀           </td><td style="border: 1px solid #ccc; padding: 5px;"> universal   </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> ∃           </td><td style="border: 1px solid #ccc; padding: 5px;"> existential </td></tr> </table></p><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> Available predicates </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>x ∈ L</tt>      </td><td style="border: 1px solid #ccc; padding: 5px;"> the substring x is a member of language L                     </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>_S(x,L)</tt>   </td><td style="border: 1px solid #ccc; padding: 5px;"> the substring x is followed immediately by a substring from L  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>x = y</tt>      </td><td style="border: 1px solid #ccc; padding: 5px;"> the position of substrings x and y are identical              </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>x ≠ y</tt>      </td><td style="border: 1px solid #ccc; padding: 5px;"> equivalent to (x = y)                                         </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>x ≺ y</tt>      </td><td style="border: 1px solid #ccc; padding: 5px;"> substring x precedes y                                        </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>x ≻ y</tt>      </td><td style="border: 1px solid #ccc; padding: 5px;"> substring x succeeds y                                        </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>x ≤ y</tt>      </td><td style="border: 1px solid #ccc; padding: 5px;"> substring x precedes or is in equal position with y           </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>x ≥ y</tt>      </td><td style="border: 1px solid #ccc; padding: 5px;"> substring x succeeds or is in equal position with y           </td></tr>    </table></p><p>Examples: </p><pre class="prettyprint">regex (∃x)(∃y)(x ∈ a ∧ y ∈ a ∧ x ≠ y);</pre><ul><li>denotes the languages that contains two instances of the string <tt>a</tt>, in different positions. </li></ul><pre class="prettyprint">regex (∃x)(x ∈ a) &amp; (∃y)(y ∈ b);</pre><ul><li>denotes the language that contains both a substring <tt>a</tt> and a substring <tt>b</tt>. </li></ul><pre class="prettyprint">regex (∃x)(x ∈ L ∧ ¬(∃y)(y ∈ L ∧ ¬(x = y) ) );</pre><ul><li>the language where only exactly one substring from the language <tt>L</tt> is present.  Equivalent to <tt>$.L</tt>. </li></ul><pre class="prettyprint">regex (∀y)( (y ∈ x) → (_S(a,y) ∧ _S(y,b) ) ∨ (_S(c,y) ∧ _S(y,d) ) );</pre><ul><li>the language where each instance of the string <tt>x</tt> is surrounded by <tt>a</tt> and <tt>b</tt>, or <tt>c</tt> and <tt>d</tt>.  Equivalent to: </li></ul><pre class="prettyprint">regex x =&gt; a _ b , c _ d;</pre><h1><a name="Operator_precedence"></a>Operator precedence<a href="#Operator_precedence" class="section_anchor"></a></h1><p>The following table gives the operator precedence of all regular expression operators, from highest to lowest. </p><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> Operator precedence                    </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>\ </tt>`                                  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>:</tt>                                    </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>+ * %%^%% .l .u .i .f .r</tt>             </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>~ $ $. $?</tt>                            </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>/  ///  \\\  /\/ </tt>                    </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> (concatenation)                        </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>&gt;  &lt;</tt>                                 </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>|  &amp;  -  .P. .p.</tt>                  </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>=&gt;  -&gt;  (-&gt;)  @-&gt; etc.</tt>               </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>&lt;&gt;</tt>                                   </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>.x.  .o.  .O.</tt>                        </td></tr> </table></p><h1><a name="Reserved_symbols"></a>Reserved symbols<a href="#Reserved_symbols" class="section_anchor"></a></h1><p>The following is a table of all reserved symbols in <i>foma</i> regular expressions, showing the character, the official Unicode character name, and its <a href="http://en.wikipedia.org/wiki/Code_point">Code Point</a>.  These need to be escaped (by <tt>%</tt> or enclosing a string in quotes) for their literal meaning in regular expressions. </p><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> Character  </td><td style="border: 1px solid #ccc; padding: 5px;"> Character Name  </td><td style="border: 1px solid #ccc; padding: 5px;"> Code point     </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>!</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> EXCLAMATION MARK            </td><td style="border: 1px solid #ccc; padding: 5px;">U+0021</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>&quot;</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> QUOTATION MARK              </td><td style="border: 1px solid #ccc; padding: 5px;">U+0022</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>#</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> NUMBER SIGN                 </td><td style="border: 1px solid #ccc; padding: 5px;">U+0023</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>$</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> DOLLAR SIGN                 </td><td style="border: 1px solid #ccc; padding: 5px;">U+0024</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>%</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> PERCENT SIGN                </td><td style="border: 1px solid #ccc; padding: 5px;">U+0025</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>&amp;</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> AMPERSAND                   </td><td style="border: 1px solid #ccc; padding: 5px;">U+0026</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>(</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> LEFT PARENTHESIS            </td><td style="border: 1px solid #ccc; padding: 5px;">U+0028</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>)</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> RIGHT PARENTHESIS           </td><td style="border: 1px solid #ccc; padding: 5px;">U+0029</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> ASTERISK                    </td><td style="border: 1px solid #ccc; padding: 5px;">U+002A</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>+</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> PLUS SIGN                   </td><td style="border: 1px solid #ccc; padding: 5px;">U+002B</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>,</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> COMMA                       </td><td style="border: 1px solid #ccc; padding: 5px;">U+002C</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>-</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> HYPHEN-MINUS                </td><td style="border: 1px solid #ccc; padding: 5px;">U+002D</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>.</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> FULL STOP                   </td><td style="border: 1px solid #ccc; padding: 5px;">U+002E</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>/</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> SOLIDUS                     </td><td style="border: 1px solid #ccc; padding: 5px;">U+002F</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>0</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> DIGIT ZERO                  </td><td style="border: 1px solid #ccc; padding: 5px;">U+0030</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>:</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> COLON                       </td><td style="border: 1px solid #ccc; padding: 5px;">U+003A</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>;</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> SEMICOLON                   </td><td style="border: 1px solid #ccc; padding: 5px;">U+003B</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>&lt;</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> LESS-THAN SIGN              </td><td style="border: 1px solid #ccc; padding: 5px;">U+003C</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>&gt;</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> GREATER-THAN SIGN           </td><td style="border: 1px solid #ccc; padding: 5px;">U+003E</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>?</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> QUESTION MARK               </td><td style="border: 1px solid #ccc; padding: 5px;">U+003F</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>[</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> LEFT SQUARE BRACKET         </td><td style="border: 1px solid #ccc; padding: 5px;">U+005B</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>\</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> REVERSE SOLIDUS             </td><td style="border: 1px solid #ccc; padding: 5px;">U+005C</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>]</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> RIGHT SQUARE BRACKET        </td><td style="border: 1px solid #ccc; padding: 5px;">U+005D</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>^</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> CIRCUMFLEX ACCENT           </td><td style="border: 1px solid #ccc; padding: 5px;">U+005E</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>_</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> LOW LINE                    </td><td style="border: 1px solid #ccc; padding: 5px;">U+005F</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>`</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> GRAVE ACCENT                </td><td style="border: 1px solid #ccc; padding: 5px;">U+0060</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>{</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> LEFT CURLY BRACKET          </td><td style="border: 1px solid #ccc; padding: 5px;">U+007B</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>|</tt><tt>|</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> VERTICAL LINE               </td><td style="border: 1px solid #ccc; padding: 5px;">U+007C</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>}</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> RIGHT CURLY BRACKET         </td><td style="border: 1px solid #ccc; padding: 5px;">U+007D</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>~</tt> </td><td style="border: 1px solid #ccc; padding: 5px;"> TILDE                       </td><td style="border: 1px solid #ccc; padding: 5px;">U+007E</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">¬     </td><td style="border: 1px solid #ccc; padding: 5px;"> NOT SIGN                    </td><td style="border: 1px solid #ccc; padding: 5px;">U+00AC</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">¹     </td><td style="border: 1px solid #ccc; padding: 5px;">SUPERSCRIPT ONE              </td><td style="border: 1px solid #ccc; padding: 5px;">U+00B9</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">×     </td><td style="border: 1px solid #ccc; padding: 5px;"> MULTIPLICATION SIGN         </td><td style="border: 1px solid #ccc; padding: 5px;">U+00D7</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">Σ     </td><td style="border: 1px solid #ccc; padding: 5px;"> GREEK CAPITAL LETTER SIGMA  </td><td style="border: 1px solid #ccc; padding: 5px;">U+03A3</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">ε     </td><td style="border: 1px solid #ccc; padding: 5px;"> GREEK SMALL LETTER EPSILON  </td><td style="border: 1px solid #ccc; padding: 5px;">U+03B5</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">⁻     </td><td style="border: 1px solid #ccc; padding: 5px;">SUPERSCRIPT MINUS            </td><td style="border: 1px solid #ccc; padding: 5px;">U+207B</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">₁     </td><td style="border: 1px solid #ccc; padding: 5px;">SUBSCRIPT ONE                </td><td style="border: 1px solid #ccc; padding: 5px;">U+2081</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">₂     </td><td style="border: 1px solid #ccc; padding: 5px;">SUBSCRIPT TWO                </td><td style="border: 1px solid #ccc; padding: 5px;">U+2082</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">→     </td><td style="border: 1px solid #ccc; padding: 5px;"> RIGHTWARDS ARROW            </td><td style="border: 1px solid #ccc; padding: 5px;">U+2192</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">↔     </td><td style="border: 1px solid #ccc; padding: 5px;"> LEFT RIGHT ARROW            </td><td style="border: 1px solid #ccc; padding: 5px;">U+2194</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">∀     </td><td style="border: 1px solid #ccc; padding: 5px;"> FOR ALL                     </td><td style="border: 1px solid #ccc; padding: 5px;">U+2200</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">∃     </td><td style="border: 1px solid #ccc; padding: 5px;"> THERE EXISTS                </td><td style="border: 1px solid #ccc; padding: 5px;">U+2203</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">∅     </td><td style="border: 1px solid #ccc; padding: 5px;"> EMPTY SET                   </td><td style="border: 1px solid #ccc; padding: 5px;">U+2205</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">∈     </td><td style="border: 1px solid #ccc; padding: 5px;"> ELEMENT OF                  </td><td style="border: 1px solid #ccc; padding: 5px;">U+2208</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">∘     </td><td style="border: 1px solid #ccc; padding: 5px;"> RING OPERATOR               </td><td style="border: 1px solid #ccc; padding: 5px;">U+2218</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">∥    </td><td style="border: 1px solid #ccc; padding: 5px;"> PARALLEL TO                 </td><td style="border: 1px solid #ccc; padding: 5px;">U+2225</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">∧     </td><td style="border: 1px solid #ccc; padding: 5px;"> LOGICAL AND                 </td><td style="border: 1px solid #ccc; padding: 5px;">U+2227</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">∨     </td><td style="border: 1px solid #ccc; padding: 5px;">LOGICAL OR                   </td><td style="border: 1px solid #ccc; padding: 5px;">U+2228</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">∩     </td><td style="border: 1px solid #ccc; padding: 5px;">INTERSECTION                 </td><td style="border: 1px solid #ccc; padding: 5px;">U+2229</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">∪     </td><td style="border: 1px solid #ccc; padding: 5px;"> UNION                       </td><td style="border: 1px solid #ccc; padding: 5px;">U+222A</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">≤     </td><td style="border: 1px solid #ccc; padding: 5px;">LESS-THAN OR EQUAL TO        </td><td style="border: 1px solid #ccc; padding: 5px;">U+2264</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">≥     </td><td style="border: 1px solid #ccc; padding: 5px;">GREATER-THAN OR EQUAL TO     </td><td style="border: 1px solid #ccc; padding: 5px;">U+2265</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">≺     </td><td style="border: 1px solid #ccc; padding: 5px;">PRECEDES                     </td><td style="border: 1px solid #ccc; padding: 5px;">U+227A</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">≻     </td><td style="border: 1px solid #ccc; padding: 5px;">SUCCEEDS                     </td><td style="border: 1px solid #ccc; padding: 5px;">U+227B</td></tr> </table></p>
 </div>
 </div>
 </td><tr>
</table>
 </div>





</div>


</article>



 </body>
</html>
